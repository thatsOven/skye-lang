impl[T] core::Slice[T] {
    fn __subscript__(const self, idx: usz) *const T {
        if idx < self.length {
            return self.ptr + idx;
        } else {
            panic("Slice: out of bounds access");
        }
    }
}

impl[T] core::Option[T] {
    fn unwrap(const self) T {
        if self.kind == core::Option::Kind::Some {
            return self.some;
        } else {
            panic("Option: unwrap on a None value");
        }
    }

    fn expect(const self, msg: String) T {
        if self.kind == core::Option::Kind::Some {
            return self.some;
        } else {
            panic(msg);
        }
    }
}

impl[T, U] core::Result[T, U] {
    fn unwrap(const self) T {
        if self.kind == core::Result::Kind::Ok {
            return self.ok;
        } else {
            panic("Result: unwrap on an Error value");
        }
    }

    fn expect(const self, msg: String) T {
        if self.kind == core::Result::Kind::Ok {
            return self.ok;
        } else {
            panic(msg);
        }
    }
}

namespace core {
    namespace utils {
        fn cStringToString(const raw: rawstring) String {
            return String.{ ptr: @cast(*const char, raw), length: core::utils::cStringLength(raw) };
        }
    }

    namespace io {
        fn print(const msg: String) {
            let _ = core::io::stdOut.write(msg);
        }

        fn println(const msg: String) {
            core::io::print(msg);
            let _ = core::io::stdOut.write("\n");
            let _ = core::io::stdOut.flush();
        }
    }

    namespace mem {
        impl core::mem::HeapAllocator {
            fn alloc[T](self, amt: usz) core::Ptr[T, Self] {
                const ptr = @cast(*T, self.allocRaw(amt * @sizeOf(T)));
                return core::Ptr::new(ptr, ptr, ptr + amt, self);
            }

            fn realloc[T](self, ptr: *core::Ptr[T, Self], size: usz) {
                const rawptr = @cast(*T, self.reallocRaw(@cast(voidptr, ptr.ptr), size * @sizeOf(T)));
                ptr.ptr = rawptr;
                ptr.min = rawptr;
                ptr.max = rawptr + size;
            }

            fn put[T](self, object: T) core::Ptr[T, Self] {
                const ptr = self.alloc[T](1);
                *ptr = object;
                return ptr;
            }

            fn free[T](self, ptr: *const core::Ptr[T, Self]) {
                self.freeRaw(@cast(voidptr, ptr.ptr));
            }
        }
    }

    struct Ptr[T, U = core::mem::HeapAllocator] {
        ptr: *T,
        min: *T,
        max: *T,
        const alloc: *U
    }

    // TODO implement pointer arithmetics
    impl[T, U = core::mem::HeapAllocator] core::Ptr[T, U] {
        fn new(ptr: *T, min: *T, max: *T, alloc: *U) Self[T, U] {
            return Self.{ ptr, min, max, alloc };
        }

        fn free(self) {
            self.alloc.free(self);
        }

        fn __subscript__(self, offs: usz) *T {
            const r = self.ptr + offs;
            if self.min <= r && r <= self.max {
                return r;
            } else {
                panic("Ptr: out of bounds access");
            }
        }

        fn __asptr__(self) *T {
            return self.ptr;
        } 
    }
}

use core::Ptr         as Ptr;
use core::io::print   as print;
use core::io::println as println;

macro MIN_ARRAY_CAPACITY 8;

namespace core {
    struct Rc[T, U = core::mem::HeapAllocator] {
        data: Ptr[T, U],
        count: u64
    }

    impl[T, U = core::mem::HeapAllocator] core::Rc[T, U] {
        fn new(data: T) Self[T, U] {
            return Self.{
                data: core::mem::heapAllocator.put(data),
                count: 1
            };
        }

        fn init(data: T, allocator: U) Self[T, U] {
            return Self.{
                data: allocator.put(data),
                count: 2
            };
        }

        fn empty() Self[T, U] {
            return Self.{
                data: core::mem::heapAllocator.alloc[T](1),
                count: 1
            };
        }

        fn from(data: Ptr[T, U]) Self[T, U] {
            return Self.{
                data, count: 1
            };
        }

        fn __copy__(self) Self[T, U] {
            return Self.{ data: self.data, count: self.count + 1 };
        }

        fn __destruct__(self) {        
            if --self.count == 0 {
                self.data.free();
            }
        }
    }

    struct ArrayIterator[T] {
        const array: *const core::Array[T],
        idx: usz
    }

    impl[T] core::ArrayIterator[T] {
        fn new(const array: *const Array[T]) Self[T] {
            return core::SliceIterator.{ array, idx: 0 };
        } 

        fn next(self) ?T {
            return self.array.get(self.idx++);
        }
    }

    struct Array[T, U = core::mem::HeapAllocator] {
        array: Ptr[T, U],
        length: usz,
        capacity: usz,
        const allocator: *U
    }

    impl[T, U = core::mem::HeapAllocator] core::Array[T, U] {
        fn new() Self[T, U] {
            return Self.{
                array: core::mem::heapAllocator.alloc[T](@MIN_ARRAY_CAPACITY),
                length: 0,
                capacity: @MIN_ARRAY_CAPACITY,
                allocator: &core::mem::heapAllocator
            };
        }

        fn init(const allocator: *U) Self[T, U] {
            return Self.{
                array: allocator.alloc[T](@MIN_ARRAY_CAPACITY),
                length: 0,
                capacity: @MIN_ARRAY_CAPACITY,
                allocator
            };
        }

        fn from(const slice: core::Slice[T]) Self[T, U] {
            const mem = core::mem::heapAllocator.alloc[T](slice.length);
            core::mem::typedBlockCopy(slice.ptr, mem.ptr, slice.length);

            return Self.{ 
                array: mem,
                length: slice.length,
                capacity: slice.length,
                allocator: &core::mem::heapAllocator
            };
        }

        fn initFrom(const slice: core::Slice[T], const allocator: *U) Self[T, U] {
            const mem = allocator.alloc[T](slice.length);
            core::mem::typedBlockCopy(slice.ptr, mem.ptr, slice.length);

            return Self.{ 
                array: mem,
                length: slice.length,
                capacity: slice.length,
                allocator
            };
        }

        fn withLength(const length: usz) Self[T, U] {
            return Self.{
                array: core::mem::heapAllocator.alloc[T](length),
                length,
                capacity: length,
                allocator: &core::mem::heapAllocator
            };
        }

        fn initWithLength(const length: usz, const allocator: *U) Self[T, U] {
            return Self.{
                array: allocator.alloc[T](length),
                length,
                capacity: length,
                allocator
            };
        }

        fn withCapacity(const capacity: usz) Self[T, U] {
            return Self.{
                array: core::mem::heapAllocator.alloc[T](capacity),
                length: 0,
                capacity,
                allocator: &core::mem::heapAllocator
            };
        }

        fn initWithCapacity(const capacity: usz, const allocator: *U) Self[T, U] {
            return Self.{
                array: allocator.alloc[T](capacity),
                length: 0,
                capacity,
                allocator
            };
        }

        fn clone(const self) Self[T, U] {
            return Self::initFrom(self.slice(0, self.length), self.allocator);
        }

        fn resize(self, const size: usz) {
            if self.capacity < size {
                do self.capacity <<= 1;
                while self.capacity < size;

                self.allocator.realloc(&self.array, self.capacity);
            }
        }

        fn resizeExact(self, const size: usz) {
            if self.capacity < size {
                self.capacity = size;
                self.allocator.realloc(&self.array, self.capacity);
            }
        }

        fn grow(self, const amt: usz) {
            if self.capacity < self.length + amt {
                do self.capacity <<= 1;
                while self.capacity < self.length + amt;

                self.allocator.realloc(&self.array, self.capacity);
            }
        }

        fn growExact(self, const amt: usz) {
            if self.capacity < self.length + amt {
                self.capacity = self.length + amt;
                self.allocator.realloc(&self.array, self.capacity);
            }
        }

        fn push(self, const item: T) {
            if self.capacity < self.length + 1 {
                self.capacity <<= 1;
                self.allocator.realloc(&self.array, self.capacity);
            }

            self.array[self.length++] = item;
        }

        fn append(self, const other: core::Array[T]) {
            for let i = 0usz; i < other.length; i++ {
                self.push(other.array[i]);
            }
        }

        fn pop(self) T {
            return self.array[--self.length];
        }

        fn get(self, const idx: usz) ?T {
            if idx < self.length {
                return (?T)::Some(self.array[idx]);
            } else {
                return (?T)::None;
            }
        }

        fn last(self) ?T {
            if self.length == 0 {
                return (?T)::None;
            } else {
                return (?T)::Some(self.array[self.length - 1]);
            }
        }

        fn __subscript__(self, const idx: usz) *T {
            if idx < self.length {
                return self.array[idx];
            } else {
                panic("Array: out of bounds access");
            }
        }

        fn slice(const self, const a: usz, const b: usz) core::Slice[T] {
            if a < self.length && b <= self.length {
                return core::Slice::new(self.array.ptr + a, b - a);
            } else {
                panic("Array: out of bounds slicing");
            }
        }

        fn reverse(self) {
            let a = 0usz;
            let b = self.length - 1;
            
            while a < b {
                let tmp       = self.array[a];
                self.array[a] = self.array[b];
                self.array[b] = tmp;

                a++;
                b--;
            }
        }

        fn iter(const self) core::ArrayIterator[T] {
            return core::ArrayIterator::new(self);
        }

        fn clear(self) {
            self.length = 0;
        }

        fn free(self) {
            self.array.free();
        }
    }

    impl[U = core::mem::HeapAllocator] core::Array[char, U] {
        fn asString(const self) String {
            return String.{ ptr: self.array.ptr, length: self.length };
        }

        fn pushString(self, const string: String) {
            for let i = 0usz; i < string.length; i++ {
                self.push(string.ptr[i]);
            }
        }

        fn stripRight(self) Self[char, U] {
            let i = self.length;

            while i-- > 0 {
                switch self.array[i] {
                    ' ' | '\n' | '\t' | '\r' {}
                    default {
                        break;
                    }
                }
            }

            return Self::initFrom(self.slice(0, i + 1), self.allocator);
        }

        fn stripLeft(self) Self[char, U] {
            let i = 0usz;

            while i < self.length {
                switch self.array[i] {
                    ' ' | '\n' | '\t' | '\r' {
                        i++;
                    }
                    default {
                        break;
                    }
                }
            }

            return Self::initFrom(self.slice(i, self.length), self.allocator);
        }

        fn strip(self) Self[char, U] {
            let a = 0usz;

            while a < self.length {
                switch self.array[a] {
                    ' ' | '\n' | '\t' | '\r' {
                        a++;
                    }
                    default {
                        break;
                    }
                }
            }

            let b = self.length;

            while b-- > 0 {
                switch self.array[b] {
                    ' ' | '\n' | '\t' | '\r' {}
                    default {
                        break;
                    }
                }
            }

            return Self::initFrom(self.slice(a, b + 1), self.allocator);
        }

        fn split[A = core::mem::HeapAllocator](self, const buf: *core::Array[Self[char, U], A], const ch: char) {
            buf.push(Self::init(self.allocator));

            for let i = 0usz; i < self.length; i++ {
                if self.array[i] == ch {
                    buf.push(Self::init(self.allocator));
                } else {
                    buf.last().unwrap().push(self.array[i]);
                }
            }
        }

        fn allocSplit[A = core::mem::HeapAllocator](self, const alloc: *A, const ch: char) core::Array[Self[char, U], A] {
            let buf = core::Array::init[Self[U], A](alloc);
            self.split(&buf, ch);
            return buf;
        }

        fn __parseIntInternal[T](self, doMinus: u8) ?T {
            let i = self.length;

            if i == 0 || ((self.array[0] < '0' || self.array[0] > '9') && self.array[0] != '-') {
                return (?T)::None;
            }

            let e = 0f64;
            let result: T = 0;

            while i-- > 0 {
                const ch = self.array[i];

                if '0' <= ch && ch <= '9' {
                    result += @cast(T, ch - 48) * @cast(T, pow(10f64, e++));
                } else if doMinus && ch == '-' {
                    if result == 0 || self.array[0] != '-' {
                        return (?T)::None;
                    }

                    result = -result;
                    break;
                } else {
                    return (?T)::None;
                }
            }

            return (?T)::Some(result);
        }

        fn parseInt[T](self) ?T {
            let buf = self.strip();
            defer buf.free();
            return buf.__parseIntInternal[T](true);
        }

        fn parseFloat[T](self) ?T {
            let stripped = self.strip();
            defer stripped.free();

            let splitted = stripped.split('.');
            defer splitted.free();

            if splitted.length > 2 {
                return (?T)::None;
            }

            let intPart: i64;
            if splitted[0].length == 0 {
                if splitted.length == 1 {
                    return (?T)::None;
                }

                intPart = 0;
            } else {
                intPart = try splitted[0].__parseIntInternal[i64](true);
            }

            if splitted.length == 1 {
                return @cast(T, intPart);
            }

            const decPartParsed = try splitted[1].__parseIntInternal[u64](false);
            const decPart = @cast(T, @cast(f64, decPartParsed) / pow(10f64, @cast(f64, splitted[1].length)));

            if intPart < 0 {
                return @cast(T, intPart) - decPart;
            } else {
                return @cast(T, intPart) + decPart;
            }   
        }
    }
}

use core::Rc as Rc;
use core::Array as Array;

impl core::io::File {
    fn read[T, U = core::mem::HeapAllocator](self, const buf: *core::Array[T, U], const amt: usz) usz {
        buf.growExact(amt);

        const r = self.readRaw(
            @cast(voidptr, buf.array.ptr + buf.length),
            @sizeOf(T), amt
        );

        buf.length += r;
        return r;
    }

    fn allocRead[T, U = core::mem::HeapAllocator](self, const alloc: *U, const amt: usz) core::Array[T, U] {
        let buf = core::Array::init[T, U](alloc);
        self.read(&buf, amt);
        return buf;
    }

    fn readLine[U = core::mem::HeapAllocator](self, const buf: *core::Array[char, U]) usz {
        let r = 0usz;

        while true {
            buf.grow(1);

            const amtRead = self.readRaw(
                @cast(voidptr, buf.array.ptr + buf.length),
                @sizeOf(char), 1
            );

            if amtRead != 1 || buf.array[buf.length] == '\n' {
                break;
            }

            buf.length++;
            r++;
        }

        return r;
    }

    fn allocReadLine[U = core::mem::HeapAllocator](self, const alloc: *U) core::Array[char, U] {
        let buf = core::Array::init[char, U](alloc);
        self.readLine(&buf);
        return buf;
    }
}

fn _SKYE_INIT() {
    core::mem::heapAllocator = core::mem::HeapAllocator::new();
    _SKYE_PRIMITIVES_INIT();
}

fn _SKYE_CONVERT_ARGS(const argc: usz, const argv: *rawstring) core::Array[String] {
    let output = core::Array::withCapacity[String](argc);

    for let i = 0usz; i < argc; i++ {
        output.push(String.{ 
            ptr: @cast(*const char, argv[i]), 
            length: core::utils::cStringLength(argv[i]) 
        });
    }

    return output;
}