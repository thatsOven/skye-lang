namespace std {
    namespace fmt {
        fn __reversedIntToString[T: AnyInt, U](const buf: *core::Array[char, U], value: T) {
            const neg = value < 0;
            if (neg) value = -value;

            do {
                buf.push(@cast(char, 48 + value % 10));
                value /= 10;
            } while value;

            if (neg) buf.push('-');
        }

        fn intToString[T: AnyInt, U](const buf: *core::Array[char, U], const value: T) {
            std::fmt::__reversedIntToString(buf, value);
            buf.reverse();
        }

        fn allocIntToString[T: AnyInt, U](const allocator: *U, const value: T) core::Array[char, U] {
            let buf = core::Array::init[char, U](allocator);
            std::fmt::intToString(&buf, value);
            return buf;
        }

        fn floatToString[T: AnyFloat, U](const buf: *core::Array[char, U], const value: T, const decPrecision: usz) {
            if decPrecision < 0 {
                panic("std::fmt::floatToString: Negative precision");
            }

            const intPart = @cast(i64, value);
            const decPart = value - @cast(T, intPart);

            std::fmt::intToString(buf, intPart);

            if decPrecision != 0 {
                buf.push('.');

                decPart *= @cast(T, pow(10f64, @cast(f64, decPrecision)));

                let tmpBuf = core::Array::new[char, U]();
                defer tmpBuf.free();
                std::fmt::__reversedIntToString(&tmpBuf, decPart);
                tmpBuf.reverse();
                
                while tmpBuf.length < decPrecision {
                    tmpBuf.push('0');
                }

                buf.pushString(tmpBuf.asString());
            }
        }

        fn allocFloatToString[T: AnyFloat, U](const allocator: *U, const value: T, const decPrecision: usz) core::Array[char, U] {
            let buf = core::Array::init[char, U](allocator);
            std::fmt::floatToString(&buf, value, decPrecision);
            return buf;
        }
    }
}
